[본문](http://terasolunaorg.github.io/guideline/5.5.1.RELEASE/ja/Overview/ApplicationLayering.html)

본 가이드라인에서는 어플리케이션을 3개의 레이어로 나눈다

- 어플리케이션 층
- 도메인 층
- 인프라스트럭쳐 층

각 층에서는 이하의 컴포넌트가 포함된다

![image](https://user-images.githubusercontent.com/56301069/75420448-f4959480-592f-11ea-85ad-b343286ea2e9.png)

- 어플리케이션 층과 인프라스트럭쳐 층은 도메인 층에 의존하지만, 도메인 층이, 타 층에 의존해서는 안된다

도메인층의 변경으로 어플리케이션 층에 변경이 생기는것은 괜찮지만, 어플레케이션 층의 변경으로 도메인 층의 변경이 생겨서는 안된다

# 2.4.1. 레이어의 정의

입력에서 출력까지의 데이터의 흐름은 어플리케이션 층 → 도메인 층 → 인프라스트럭쳐 층으로 있기 때문에, 이 순서로 설명한다

## 2.4.1.1 어플리케이션 층

어플리케이션 층은, 클라이언트의 데이터의 입출력을 제어하는 층이다.

이 층은,

- 데이터의 입출력을 이행하는 UI(User Interface)의 제공
- 클라이언트부터의 리퀘스트핸들링
- 입력 데이터의 타당성 체크
- 리퀘스트 내용에 대응하는 도메인 층의 컴포넌트 호출

등의 구현을 한다

이 층에서의 구현은 가능하면 가볍게 해야하며, 비지니스룰을 포함해서는 안된다

### 2.4.1.1.1. Controller

Controller는 주로 이하의 역할을 맡는다

- 화면 전환의 제어(리퀘스트 매핑과 처리 결과에 대응하는 View를 반환한다)
- 도메인 층의 Service의 호출(리퀘스트에 대응하는 주처리를 실행한다)

Spring MVC에서는 @Controller 어플리케이션이 부여되는 POJO클래스가 해당된다

- 클라이언트와의 입출력 데이터를 섹션에 저장하는 경우, 섹션에 저장하는 데이터의 Life Cycle을 제어하는 역할을 맡는다

### 2.4.1.1.2. View

View는 클라이언트의 출력(UI의 제공을 포함한다)을 맡는다. HTML/PDF/Excel/JSON 등, 여러가지 형식으로 출력결과를 반환한다.

Spring MVC에서는, View 클래스가 해당된다

- REST API나 Ajax의 리퀘스트에서 JSON이나 XML 형식의 출력을 실행하는 경우, HttpMessageConverter 클래스가 View의 역할을 맡는다. 자세한 것은 「RESTful Web Service」을 참조한다

### 2.4.1.1.3. Form

Form은 주로 이하의 역할을 맡는다

- HTML의 폼을 표현(폼의 데이터를 Controller)에 전달하거나, 처리결과를 폼에 출력한다)
- 입력 체크 룰의 선언(Bean Validation의 어노테이션을 부여한다)

Spring MVC에서 Form오브젝트는 리퀘스트 파라미터를 유지하는 POJO클래스가 해당된다.

- 도메인 층이 어플리케이션 층에 의존하지 않게 하기 위해, 이하의 변환처리를 어플리케이션 층에서 한다
- Form에서 Domain Object(Entity 등)으로의 변환처리
- Domain Object에서 Form으로의 변환처리

이것들의 변환처리를 Controller 내부에서 실행하면, 소스 코드가 길어지고, 본래의 Controller의 처리(화면 전환 등) 결과가  나빠지기 쉽다.

변환 처리의 코드가 많아지게 되면, 이하의 대책을 실행하게 된다. Controller 내의 소스코드를 심플한 상태로 지키는것을 추천한다

- Helper클래스를 작성하여 변환처리를 위양한다(위임한다)
- Doze를 사용한다

### 2.4.1.1.4. Helper

Heleper는 Controller를 보유하는 역할을 맡는다.

Helper의 작성은 옵션이다. 필요한 경우에만 하고, POJO 클래스로 작성한다.

- Controller의 역할은 루팅(URL 매핑과 전환처의 반환)이고, 그것 이외의 처리(Java Bean의 변환 등)이 필요할 경우 Helper에서 끊어내고, 그 쪽에 처리를 위양하는 것을 추천한다.

Helper는 Controller의 코드를 보기 좋게 하는 것이기 때문에, Helper는 Controller의 일부로써 사용하는 것이 좋다(Controller 내부의 private 메소드 같은 것이다)

## 2.4.1.2 도메인 층

도메인 층은 어플리케이션의 중심이 되는 층이다. 비지니스 룰을 실행(업무처리를 제공)한다.

이 층에서는

- Domain Object
- Domain Object에 해당하는 비지니스룰의 체크(계좌에 입금하는 경우, 잔고가 충분한가의 체크 등)
- Domain Object에 해당하는 비지니스 룰의 실행(비지니스 룰에 따르는 가치의 반영)
- Domain Object에 해당하는 CRUD 조작

등을 실행한다.

도메인 층은 다른 층에서는 통하지 않고, 재이용가능하다.

### 2.4.1.2.1. Domain Object

Domain Object는 비지니스를 실행하며 필요한 자원이나 비지니스를 실행하는 과정에서 발생하는 것들을 표현하는 모델이다.

Domain Object는 크게 3개로 나뉜다.

- Employee나 Customer, Product등의 리소스 계열의 모델(일반적으로는 명사로 표현한다)
- Order, Payment등 이벤트 계열의 모델(일반적으로는 동사로 표현한다)
- YearlySales, MonthlySales 등 정리한 문서 계열의 모델

데이터베이스의 테이블의 1개의 레코더를 표현하는 클래스인 Entity는 Domain Object이다

- 이 가이드라인에서는 주로 상태만을 가진 모델을 다룬다

Martin Flower의 "Patterns of Enterprise Application Architecture에서는 Domain Model은 상태와 행동을 가진 것이라고 정의하지만, 엄밀히는 움직이지 않는다.

### 2.4.1.2.2 Repostory

Domain Object의 컬렉션같은 위치이고, Domain Object의 조회(문의)나 작성, 갱신, 삭제 같은 CRUD처리를 담당한다.

이 층에서는 인터페이스만을 정의한다.

실제로는 인프라스트럭쳐 층의 RepositoryImpl에서 구현하기 때문에, 어떠한 데이터 액세스가 실행되고 있는가에 대한 정보는 가지고 있지 않다.

### 2.4.1.2.3 Service

업무처리를 제공한다.

본 가이드라인에서는 Service의 메소드를 트랜잭션 경계로 하는 것을 추천하고 있다.

- Service에서는 Form이나 HttpRequest등 Web과 관련된 정보를 다뤄서는 안된다.

이것들의 정보는 Service 메소드를 호출하기 전에 어플리케이션 층에서 도메인 층의 오브젝트에 변환해야만 한다.

## 2.4.1.3 인프라스트럭쳐 층

인프라스트럭쳐 층은 도메인 층(Repository인터페이스)의 구현을 제공하는 층이다.

데이터스토어(RDBMS나 NoSQL등의 데이터를 저장하는 장소)의 영속화나 메세지 송신 등을 담당한다.

### 2.4.1.3.1 RepositoryImpl

RepositoryImpl은 Repository 인터페이스의 구현으로써, Domain Object의 Life Cycle관리를 실행하는 처리를 제공한다.

RepositoryImpl의 구현은 Repository인터페이스에 있어 은폐되기 때문에, 도메인 층의 컴포넌트(Service 등)에서는 어떠한 데이터 엑세스 되어있는가 의식하지않고 끝난다.

요건에 따라서는, 이 처리도 트랜잭션 경계가 될 수 있다.

- MyBatis3나 Spring Data JPA를 사용하는 경우는, RepositoryImpl의 실체를 (일부)자동으로 작성하는 구조가 제공된다

### 2.4.1.3.2 O/R Mapper

O/R Mapper는 데이터 베이스와 Entity의 상호 매핑을 담당한다.

MyBatis / JPA / Spring JDBC가 본 기능을 제공한다.

구체적으로는

- MyBatis3을 사용하는 경우, Mapper인터페이스 또는 SqlSession
- JPA를 사용하는 경우, EntityManager
- Spring JDBC를 사용하는 경우, JdbcTemplate

가 O/R Mapper에 해당한다.

O/R Mapper는 Repository인터페이스의 구현에 사용된다.

- MyBatis, Spring JDBC는 O/R Mapper라고 하기보다 SQL Mapper라고 부르는 쪽이 정확하지만, 본 가이드라인에서는 O/R Mapper라고 분류한다.

### 2.4.1.3.3 Integration System Connector

Integration System Connector는, 데이터 베이스 이외의 데이터 스토어(메세지 시스템, Key-Value-Store, Web서비스, 기존 시스템, 외부 시스템 등)와의 연계를 담당한다.

Integration System Connector는 Repository 인터페이스의 구현에 사용된다.

## 2.4.2 레이어 간의 의존관계

서두에 설명했다시피, 도메인 층이 중심이 되고, 어플리케이션 층, 인프라스트럭쳐가 그것에 의존하는 형태가 된다.

본 가이드라인에서는 구현기술로써,

- 어플리케이션 층에 Spring MVC
- 인프라스트럭쳐에 MyBatis, Spring Data JPA

를 사용하는 것을 상정하고 있지만, 본질적으로는, 구현기술이 변해도, 각 각의 층에서 차이가 흡수되어, 도메인 층에는 영향을 주지 않는다.레이어 간의 결합부는 인터페이스로 공개하는 것으로, 각 층이 사용하고 있는 구현 기술에 의존하지 않는 형식이 될 수 있다.

레이어 화를 의식하여, 소결합한 설계를 실행한 것을 추천한다.

- 소결합(疎結合, Loose coupling)

시스템의 구성요소 간의 연결이나 서로의 의존관계, 관련성 등이 약해 각 각의 독립성이 높은 상태를 말한다. 역으로, 요소 간의 결합력이 강해 독립성이 낮은 상태는 밀결합(密結合, Tight coupling)이라고 한다.

![image](https://user-images.githubusercontent.com/56301069/75420467-fe1efc80-592f-11ea-95f8-0421f9d64ff8.png)

각 레이어의 오브젝트의 의존관계는 DI 컨테이너에 의해 해결된다.

![image](https://user-images.githubusercontent.com/56301069/75420472-00815680-5930-11ea-8dbe-f601ebb94191.png)

## 2.4.2.1 Repository를 사용할 때의 처리 흐름

입력에서 출력까지의 흐름을 표현하면 그림과 같이 된다.

![image](https://user-images.githubusercontent.com/56301069/75420482-04ad7400-5930-11ea-928d-8bb25c0fbc11.png)

갱신계의 처리를 예로, 시퀀스를 설명한다.

1. Controller가 Request를 받는다
2. (Optional) Controller는 Helper를 호출하고, Form의 정보를 Domain Object 또는 DTO로 변환한다
3. Controller는 Domain Object 또는 DTO를 사용하여 Service를 호출한다
4. Service는 Repository를 호출하여 업무처리를 한다
5. Repository는 O/R Mapper를 호출하여, Domain Object 또는 DTO를 영속화한다
6. (의존관계) O/R Mapper는 DB에 Domain Object 또는 DTO의 정보를 보존한다
7. Service는 업무처리결과의 Domain Object 또는 DTO를 Controller에 반환한다
8. (Optional) Controller는 Helper를 호출하여 Domain Object 또는 DTO를 Form에 반환한다
9. Controller는 전환처의 View 이름을 반환한다
10. View는 Response를 출력한다

각 컴포넌트 간의 호출 가능, 불가능을 아래에 정리한다.

[컴포넌트 간의 호출 가능, 불가능](https://www.notion.so/ea1ddba7463e49a3a370136daea93b8b)

주의해야 할것은 기본적으로 Service에서 Service의 호출은 금지되어있다는 점이다.

만약 다른 서비스에서 이용가능한 서비스가 필요한 경우, 호출 가능, 불가능을 명확하게 하기 위해, SharedService를 작성한다.

- 호출 가능, 불가능 룰을 지키는 것은 어플리케이션 개발의 초기 단계에서는 귀찮게 느껴질지도 모른다. 확실히, 한가지 처리만을 보면, 예를 들어, Controller에서 직접 Repository를 호출하는 편이 빨리 어플리케이션을 작성할 수 있다. 하지만, 룰을 지키지 않을 경우, 개발규모가 커지게 되었을 경우, 수정 영향 범위를 알기 어렵게 되거나, 횡단적인 공통 처리를 추가하기 어렵게 되는 등, 보존성에 큰 문제가 발생한느 경우가 많다. 후에 문제가 되지 않도록, 처음부터 의존관계를 붙여 개발하는 것을 강력 추천한다.

※횡단적 : 여러 분야에 걸쳐 연결, 연결점이 있는 모양

## 2.4.2.2 Repository를 사용하지 않을 때의 처리 흐름

Repository를 작성함으로써, 영속화기술을 은폐할 수 있게되고, 데이터 액세스 처리를 공통화 가능해지게 되는 등의 메리트가 있다.

하지만, 프로젝트의 팀 체제에 있어서는, 데이터 액세스의 공통화 어려운 경우가 많다(많은 회사가 서로 다른 업무처리를 구현하여, 공통화의 컨트롤이 어려운 경우 등). 그런 경우 , 데이터 액세스의 추상화가 필요하지 않다면, Repository는 작성하지 않고, 이하의 그림과 같이 Service에서 직접 O/R Mapper를 호출하면 된다.

![image](https://user-images.githubusercontent.com/56301069/75420495-0a0abe80-5930-11ea-83a4-bf5d5e79c937.png)

[컴포넌트 간의 호출 가능, 불가능(without Repository)](https://www.notion.so/80f7bf800ce34200a70cc50d5e3a9f7d)

## 2.4.3. 프로젝트 구성

상기와 같이 어플리케이션의 레이어 화를 진행한 경우 추천하는 구성에 대해서 설명한다.

여기서는 Maven의 표준 디렉토리 구성을 전제로 한다.

기본적으로는, 아래의 구성으로 멀티프로젝트를 작성하는 것을 추천한다.

- [projectName]-domain

도메인 층과 관련되어 있는 클래스, 설정 파일을 저장하는 프로젝트

- [projectName]-web

어플리케이션 층과 관련된 클래스, 설정 파일을 저장하는 프로젝트

- [projectName]-env

환경에 의존하는 파일 등을 저장하는 프로젝트

- RepositoryImpl 등의 인프라스트럭쳐 층의 클래스도 project-domain에 포함시킨다.

본래, [projectName]-infra 프로젝트를 별도로 작성했지만, 보통 infra프로젝트를 은폐화할 필요가 없고, domain 프로젝트에 저장하는 편이 개발하기 쉽다. 필요하다면 [projectName]-infra에 작성해도 괜찮다.

## 2.4.3.1. [projectName]-domain

[projectName]-domain의 프로젝트 추천구성은 아래와 같다.

    [projectName]-domain
      └src
          └main
              ├java
              │  └com
              │      └example
              │          └domain ...(1)
              │              ├model ...(2)
              │              │  ├Xxx.java
              │              │  ├Yyy.java
              │              │  └Zzz.java
              │              ├repository ...(3)
              │              │  ├xxx
              │              │  │  └XxxRepository.java
              │              │  ├yyy
              │              │  │  └YyyRepository.java
              │              │  └zzz
              │              │      ├ZzzRepository.java
              │              │      └ZzzRepositoryImpl.java
              │              └service ...(4)
              │                  ├aaa
              │                  │  ├AaaService.java
              │                  │  └AaaServiceImpl.java
              │                  └bbb
              │                      ├BbbService.java
              │                      └BbbServiceImpl.java
              └resources
                  └META-INF
                      └spring
                          ├[projectName]-codelist.xml ...(5)
                          ├[projectName]-domain.xml ...(6)
                          └[projectName]-infra.xml ...(7)

1. 도메인 층의 구성 요소를 저장하는 패키지
2. Domain Object를 저장하는 패키지
3. Repository를 저장하는 패키지
4. 서비스를 저장하는 패키지
5. 코드 리스트의 Bean 정의를 저장한다
6. 도메인 층에 관련된 Bean 정의를 저장한다
7. 인프라 스트럭쳐 층에 관련된 Bean 정의를 저장한다

## 2.4.3.2. [projectName]-web

[projectName]-web의 프로젝트 추천구성은 아래와 같다.

    [projectName]-web
      └src
          └main
              ├java
              │  └com
              │      └example
              │          └app ...(1)
              │              ├abc
              │              │  ├AbcController.java
              │              │  ├AbcForm.java
              │              │  └AbcHelper.java
              │              └def
              │                  ├DefController.java
              │                  ├DefForm.java
              │                  └DefOutput.java
              ├resources
              │  ├META-INF
              │  │  └spring
              │  │      ├applicationContext.xml ...(2)
              │  │      ├application.properties ...(3)
              │  │      ├spring-mvc.xml ...(4)
              │  │      └spring-security.xml ...(5)
              │  └i18n
              │      └application-messages.properties ...(6)
              └webapp
                  ├resources ...(7)
                  └WEB-INF
                      ├views ...(8)
                      │  ├abc
                      │  │ ├list.jsp
                      │  │ └createForm.jsp
                      │  └def
                      │     ├list.jsp
                      │     └createForm.jsp
                      └web.xml ...(9)

1. 어플리케이션 층의 구성 요소를 저장하는 패키지

1. 어플리케이션 전체와 관련된 Bean 정의를 저장한다
2. 어플리케이션에서 사용하는 Property를 저장한다
3. Spring MVC의 설정을 저장한 Bean 정의를 저장한다
4. SpringSecurity의 설정을 저장한 Bean 정의를 저장한다
5. 화면표시용 메세지(국제화대응) 정의를 저장한다
6. 정적 리소스(css,  화상)을 저장한다
7. View(jsp)를 저장한다
8. Servlet의 Property 정의를 저장한다

- [projectName]-domain과 [projectName]-web를 나누는 이유는, 의존관계의 역전을 막기 위해서다.

[projectName]-web이 [projectName]-domain을 사용하는 것은 당연하지만, [projectName]-domain이 [projectName]-web을 참조해서는 안된다. 

한개의 프로젝트에서 [projectName]-web과 [projectName]-domain의 구성요소를 정리해놓으면, 실수하여 잘못된 참조를 하는 경우가 있다. 프로젝트를 나누어 참조순서를 정하여 [projectName]-domain이 [projectName]-web을 참조할 수 없게 하는 것을 강력추천한다.