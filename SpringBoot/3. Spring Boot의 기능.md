## 1. Spring Application
SpringApplication 클래스는 main() 메소드에서 시작된 Spring 어플리케이션을 부트스트랩하는 편리한 방법을 제공합니다. 

기본적으로 INFO 로깅 메세지가 표시됩니다. 여기에는 어플리케이션을 기동한 유저 등 관련 시작 정보등이 포함됩니다. INFO 이외의 로그 레벨이 필요한 경우 로그레벨의 설명에 따라 설정할 수 있습니다. 어플리케이션 버전은 메인 어플리케이션 클래스의 패키지의 구현 버전을 사용하여 결정됩니다. spring.main.log-startup-info를 false로 설정하면 시동 정보 로깅을 해제할 수 있습니다. 이렇게 하면, 어플리케이션의 활성 프로파일의 로그도 꺼집니다.

> 부팅 시 추가 로그를 하려면 SpringApplication의 서브 클래스에서 logStartupinfo(boolean)을 재정의합니다.

### 1.1. 기동 실패
어플리케이션의 기동에 실패했을 경우, 등록된 `FailureAnalyzers`로, 전용 에러메세지와 문제를 수정하기 위한 구체적인 행동을 제공합니다. 

장애 분석기(Analyzer)가 예외를 처리할 수 없는 경우에도, 완전한 상태 보고서를 표시하여 문제의 원인을 보다 쉽게 이해할 수 있습니다. 이것을 사용하기 위해서는 debug 프로퍼티를 활성화하거나 org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener의 DEBUG 로깅을 활성화해야합니다.

예를 들면 java -jar를 사용하여 어플리케이션을 실행할 때, 다음과 같이 debug 속성을 사용할 수 있습니다.

```bash
$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug
```

### 1.2. 초기화 지연
SpringApplication을 사용하면, 어플리케이션을 지연적으로 초기화할 수 있습니다. 초기화 지연이 활성화되면, Bean은 어플리케이션 기동시가 아니라 필요에 따라 만들어집니다. 그 결과, 지연 초기화를 사용하면 어플리케이션의 부팅 시간을 단축시킬 수 있습니다. Web 어플리케이션은 지연 초기화를 사용하면 HTTP 리퀘스트를 수신하기 까지 많은 Web 관련 Bean이 초기화되지 않습니다.

지연 초기화의 단점은 어플리케이션의 문제 발견을 지연시킬 가능성이 있습니다. 잘못 구성된 Bean이 지연초기화 된 경우 부팅할 때 오류가 발생하지 않고, Bean이 초기화 된 경우에만 문제가 드러납니다. 또, JVM에서 시작할 때 초기화되는 Bean뿐만 아니라 어플리케이션의 모든 Bean을 수용하기에 충분한 메모리가 있는 것을 확인할 필요가 있습니다. 이러한 이유로 지연 초기화는 기본적으로 활성화되어 있지 않기 때문에 지연초기화를 사용하기 전에 JVM의 힙 사이즈의 조정을 할 것을 권장합니다.

초기화 지연은 SpringApplicationBuilder의 LazyInitialization 메소드 또는 SpringApplication의 SetLazyInitialization 메소드를 사용하여 프로그램을 사용할 수 있습니다. 또는, 다음의 예와 같이 spring.main.lazy-initialization 프로퍼티를 사용하여 활성화시킬 수 있습니다.

```java
spring.main.lazy-initialization=true
```

> 나머지 어플리케이션으로 초기화 지연을 사용할 때, 특정 Bean의 지연 초기화를 해제하려면, @Lazy(false) 어노테이션을 사용하여 지연 속성을 명시적으로 false로 설정할 수 있습니다.

### 1.3. 배너의 사용자 정의
부팅 시에 출력되는 배너를 변경하가 위해서는 banner.txt 파일을 클래스에 추가하거나 spring.banner.location 속성을 이러한 파일의 위치에 설정합니다. 파일에 UTF-8 이외의 Encode가 포함되어 있을 경우 spring.banner.charset을 설정할 수 있습니다. 텍스트 파일을포함하여 .gif, .jpg 또는 .png 이미지 파일을 클래스 파일에 추가하거나 spring.banner.image.location 속성을 설정하는 것도 가능합니다. 이미지는 ASCII 아트 표현로 교체되어 텍스트 배너로 출력됩니다.

banner.txt 파일 안에는 다음 플레이스홀더 중 하나를 사용할 수 있습니다.

### 1.4. SpringApplication의 사용자 정의
SpringApplication의 디폴트를 변경하고 싶을 경우 로컬 인스턴스를 작성하여 커스터마이즈할 수 있습니다.
ex. 배너를 띄우고 싶지 않을 경우.

```java
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MySpringConfiguration.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}
```

> `SpringApplication`에 전달되는 생성자 인수는 Spring Bean의 구성 소스입니다. 대부분의 경우 이들은 @Configuration 클래스에 대한 참조이지만, XML 구성 또는 스캔할 필요가 있는 패키지에 대한 참조일 수도 있습니다.

### 1.5. Fluent Builder API
AppilcationContext 계층 ( 부모 / 자식 관계를 가진 복수의 컨텍스트)를 구축해야하거나 "흐르는 듯한" 빌더 API를 사용하는경우 SpringApplicationBuilder를 사용할 수 있습니다.

```java
new SpringApplicationBuilder()
        .sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);
```

> `ApplicationContext` 계층을 사용할 경우 몇 가지 제약이 있습니다. 예 : Web 컴포넌트는 자식 컨텍스트 안에 포함되어야 하며, 같은 `Environment`가 부모 컨텍스트와 자식 컨텍스트 양측 모두에 사용됩니다.

### 1.7. Web 환경
`SpringApplication`은 사용자를 대신하여 올바른 타입의 ApplicationContext를 작성하려고 합니다. WebApplicationType을 결정하는데 사용되는 알고리즘은 매우 간단합니다.

- Spring MVC가 존재할 경우 `AnnotationConfigServletWebServerApplicationContext`가 사용됩니다.
- Spring MVC가 존재하지 않고, Spring WebFlux가 존재할 경우 `AnnotationConfigReactiveWebServerApplicationContext`가 사용됩니다.
- 그 외에는, `AnnotationConfigApplicationContext`가 사용됩니다.

이건 같은 어플리케이션에서 Spring MVC와 Spring WebFlux의 새로운 WebClient를 사용하고 있을 경우, 디폴트로 Spring MVC가 사용됨을 뜻합니다. `setWebApplicationType(WebApplicationType)`을 호출하는 것으로 간단하게 재정의할 수 있습니다.

`setApplicationContextClass(…​)`을 호출하는 것으로 사용되는 `ApplicationContext` 타입을 완전히 제어할 수 있습니다.

> JUnit 테스트에서 `SpringApplication`을 사용할 경우 `setWebApplicationType(WebApplicationType.NONE)`을 호출하는 것이 바람직할 경우가 많습니다.

### 1.8. 어플리케이션 인수에 대한 접근
`SpringApplication.run(…​)`에 건네어진 어플리케이션 인수에 접근해야 할 경우 `org.springframework.boot.ApplicationArguments` Bean을 주입할 수 있습니다. ApplicationArguments 인터페이스는 다음과 같이 미가공의 String[] 인수로 분석된 option 및 non-option 인수 양측에 대한 접근을 제공합니다.

```java
import org.springframework.boot.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.*;

@Component
public class MyBean {

    @Autowired
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List<String> files = args.getNonOptionArgs();
        // if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
    }

}
```

> Spring Boot는 `CommandLinePropertySource`를 Spring Environmnet에 등록합니다. 이에 따라, @Value 어노테이션을 사용하여, 단일 어플리케이션 인수를 주입할 수 있습니다.

### 1.9. ApplicationRunner 또는 CommandLineRunner의 사용
SpringApplication의 부팅 후 특정 코드를 실행하고 싶을 경우 ApplicationRunner 또는 CommandLineRunner 인터페이스를 구현합니다. 두 개의 인터페이스는 똑같이 작동하며, SpringApplication.run(..)이 완료되기 직전에 호출되는 단일 run 메소드를 제공합니다.

`CommandLineRunner` 인터페이스는 단순한 문자열배열로 어플리케이션 인수에 대한 접근을 제공하지만, ApplicationRunner는 위의 ApplicationArguments 인터페이스를 실행합니다.

```java
import org.springframework.boot.*;
import org.springframework.stereotype.*;

@Component
public class MyBean implements CommandLineRunner {

    public void run(String... args) {
        // Do something...
    }

}
```

특정 순서로 호출될 필요가 있는 복수의 CommandLineRunner 또는 ApplicationRunner Bean이 정의되어 있을 경우, org.springframework.core.Ordered 인터페이스를 더해 구현하거나, org.springframework.core.annotation.Order를 사용한다.

# 2.0.