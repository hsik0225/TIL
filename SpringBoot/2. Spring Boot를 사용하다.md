## 2.2. 메인 어플리케이션의 특정
보통, 메인 어플리케이션 클래스를 다른 클래스에 있는 루트 패키지에 배치하는것을 추천합니다. @SpringBootApplication 어노테이션은 보통 도메인 클래스에 배치되고, 특정 아이템의 베이스 "탐색 패키지"를 암시적으로 정의합니다. 
- 예 : JPA 어플리케이션을 작성하고 있을 경우, @SpringBootApplication 어노테이션이 붙은 클래스의 패키즈를 사용하여 @Entity 아이템을 탐색합니다. 루트 패키지를 사용하면, 컴포넌트 스캔을 프로젝트에게만 적용하는 것이 가능합니다.

> @SpringBootApplication을 사용하지 않는 경우, @EnableAutoConfiguration 및 @ComponentScan 어노테이션을  대신해 사용할 수도 있습니다.

## 3.1. 추가 구성 클래스의 임포트
모든 @Configuration을 하나의 클래스에 넣을 필요는 없습니다. @Import 어노테이션을 사용하여 추가 구성 클래스를 임포트할 수 있습니다. 또는, @ComponentScan을 사용하여, @Configuration클래스를 포함하는 모든 Spring 컴포넌트를 자동으로 얻을 수 있습니다.

# 4. 자동구성
Spring Boot 자동구성은 추가한 jar 의존관계를 기본으로 Spring 어플리케이션을 자동적으로 구성하려고 합니다. 

- 예  :
HSQLDB가 클래스 패스에 있고, 데이터베이스 접속 Bean을 수동으로 구성하고 있지 않을 경우 Sprinng Boot는 메모리 안에 데이터베이스를 자동구성합니다.

@EnableAutoConfiguration 또는 @SpringBootApplication 어노테이션을 @Configuration 클래스의 1개에 추가하고 자동구성을 Opt-In(탈퇴)할 필요가 있습니다.

> @SpringBootApplication 또는 @EnableAutoConfiguration 어노테이션을 1개만 추가해주세요. 보통, 프라이머리 @Configuration 클래스에만 어떤 것을 추가하는 것을 추천합니다

## 4.1. 자동구성의 단계적 대체
자동구성은 비침략적입니다. 언제든지 자신의 구성을 정의하고 자동구성의 특정 부분을 대체할 수 있습니다.

- 예 :
자신의 DataSource Bean을 추가하면, 디폴트 내장 데이터베이스 서포트는 원래대로 돌아갑니다.

현재 적용되고 있는 자동구성과 그 이유를 알아볼 필요가 있을 경우 --debug 스위치를 사용하여 어플리케이션을 개시해주세요. 그러면, 선택한 코어 로거(Logger)의 디버그 로거가 활성화되고, 콘솔에 상태 보고서가 기록됩니다.

## 4.2. 특정 자동구성 클래스를 무효로 한다
불필요한 특정 자동구성 클래스가 적용되고 있을 경우 다음과 같이 @SpringBootApplication의 exclude 속성을 사용하여 해제할 수 있습니다.

```java
import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.*;

@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})
public class MyApplication {
}
```

클래스가 클래스 패스에 없을 경우 어노테이션의 excludeName 속성을 사용하여 대신 완전자격이름을 지정할 수 있습니다. @SpringBootApplication, exclude 및 excludeName이 아니라 @EnableAutoConfiguration을 사용할 경우도 이용할 수 있습니다. 마지막으로, spring.autoconfiguration.exclude 프로퍼티를 사용하여 제외 자동구성 클래스의 리스트를 제어할 수 있습니다.

> 어노테이션 레벨과 프로퍼티의 사용의 양측에서 제외를 정의할 수 있습니다

자동구성 클래스는 `public`이지만, 퍼블릭 API라고 보여지는 클래스의 유일한 측면은, 자동구성을 해제하는데 사용할 수 있는 클래스의 이름입니다. 중첩된 구성 클래스나 Bean 메소드 등의 클래스의 실제 내용은 내부전용이고 직접사용하는 것은 추천하지 않습니다.

# 5. Spring Bean과 의존성 주입
Bean과 그 주입된 의존관계를 정의하기 위해 표준 Spring Framework 기법을 자유롭게 사용할 수 있습니다. 간단하게 @ComponentScan을 사용하거나 (Bean을 찾아낸다), @Autowired를 사용하여(생성자 주입을 한다) 작성하는 경우가 많습니다.

위에서 말한것처럼 코드를 구성할 경우(어플리케이션 클래스를 루트 패키지에 배치할 경우) 인수없이 @ComponentScan을 추가할 수 있습니다. 모든 어플리케이션 컴포넌트(@Component, @Service, @Repository, @Controller 등)은 Spring Bean으로 자동으로 등록됩니다.

다음 예는 생성자 주입을 사용하여 불필요한 RiskAssessor Bean을 얻는 @Service Bean을 가리키고 있습니다.

```java
package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    @Autowired
    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}
```

Bean에 1개의 생성자가 있을 경우 다음과 같이 @Autowired를 생략할 수 있습니다.

```java
@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}
```

> 생성자 인젝션을 사용하면 `riskAccessor` 필드가 `final`로 마크되어 이후 변경할 수 없게 되는 것에 주의해주세요

# 6. @SpringBootApplication 어노테이션의 사용
많은 Spring Boot 개발자는 자동구성, 컴포넌트 스캔을 사용하여, "어플리케이션 클래스"로 추가 자동구성을 정의할 수 있는 어플리케이션을 선호합니다. 하나의 @SpringBootApplication 어노테이션을 사용하여 이러한 3개의 기능을 사용할 수 있습니다.

- @EnableAutoConfiguration : Spring Boot의 자동구성 메커니즘을 사용한다
- @ComponentScan : 어플리케이션이 배치되어 있는 패키지에서 @Component 스캔을 사용한다
- @Configuration : Context에 추가 Bean을 동록하거나 추가 구성 클래스를 임포트할 수 있습니다.

```java
package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
```

> 이러한 기능은 모두 필수가 아닙니다. 이 단일 어노테이션을 사용하는 기능들을 대체할 수 있습니다. 예를 들면, 어플리케이션에서 컴포넌트 스캔 또는 구성 프로퍼티 스캔을 사용하고 싶지 않을 경우가 있습니다.

```java
package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.context.annotation.ComponentScan
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@Import({ MyConfig.class, MyAnotherConfig.class })
public class Application {

    public static void main(String[] args) {
            SpringApplication.run(Application.class, args);
    }

}
```

이 예에서는 `Application`은 `@Component` 어노테이션이 붙은 클래스와 `@ConfigurationProperties`어노테이션이 붙은 클래스가 자동으로 검출되지 않고, 유저 정의 Bean이 명시적으로 임포트되는 것을 제외하고 다른 Spring Boot 어플리케이션과 똑같습니다.(@Import를 참조)

